---
navhome: /docs/
sort: 6
title: Subject-oriented programming Pt. 3
---

# Hoon Tutorial 1.6: Subject-oriented Programming Pt. 3

In the last lesson we finally defined arms.  At this point you should be somewhat familiar with both kinds of limbs of the subject: arms and legs.  But we haven't yet covered limb and wing resolution to an arm of the subject.  In this lesson we'll talk about how limb and wing expressions behave differently when they resolve to arms rather than legs.

## Limb Resolution to an Arm

In lesson 1.4 you learned that limb expressions can be used to produce fragments of the subject called 'legs'.  A leg is nothing more than a subject fragment; if we understand the subject as a binary tree, a leg is just a subtree.  Producing a leg of the subject is one of the two forms of limb resolution.

Returning a fragment of the subject isn't enough to allow for function calls in Hoon -- more is needed.  That's why we also have arms.  Certain limb expressions treat arms differently from the way they do legs.  Let's call this special treatment of arms 'arm resolution'.  Arm resolution doesn't return the fragment of the subject containing the arm; it evaluates the arm with its parent core as the subject.  (Remember that the parent core of an arm is the core that contains the arm in its battery.)  This evaluation generates a new noun.  This new noun is the product of limb resolution to the arm in question.

This special case of limb resolution allows for arbitrarily complex computations to be carried out.  That's because arms are Nock formulas in the subject, and Nock is a [Turing-complete](https://en.wikipedia.org/wiki/Turing_completeness) language.  

Some examples of limb resolution to arms should help clarify how limb expressions work.

### Limb Expressions

I wrote that *certain* limb expressions treat arms differently from legs.  Not all do!  An arm is just a (certain kind of) noun in the subject.  Nothing prevents you from producing that fragment of the subject if you're determined to do it.  Whether limb resolution includes an evaluation depends on the sort of limb expression you use.

#### Address-based Limb Expressions

In lesson 1.4, you saw how the following limb expressions return legs based on an address in the subject: `+n`, `.`, `-`, `+`, `+>`, `+<`, `->`, `-<`, `&`, `|` etc.  When these resolve to the part of the subject containing an arm, they *don't* evaluate the arm.  They simply return that fragment of the subject, as if it were a leg.

Let's look at the arm of our favorite gate, `add`.

```
> add
<1.vng {{a/@ b/@} <31.ohr 1.jmk $143>}>
```

As a reminder, gates are cores in which the battery (i.e., the head) contains exactly one arm and the payload (i.e. the tail) contains a pair: (i) the sample and (ii) the context.  The arm of `add` is at the head of the core above, pretty-printed as `1.vng`.  Let's use `+2` to produce that arm as a noun:

```
> +2:add
[ 6
  [5 [1 0] 0 12]
  [0 13]
  9
  2
  [0 2]
  [[8 [9 2.540 0 7] 9 2 [0 4] [0 28] 0 11] 4 0 13]
  0
  7
]
```

You saw this noun in the last lesson.  It's the Nock formula for adding two numbers together.  You can use other addressed-based limb expressions to produce that same noun:

```
> -:add
[ 6
  [5 [1 0] 0 12]
  [0 13]
  9
  2
  [0 2]
  [[8 [9 2.540 0 7] 9 2 [0 4] [0 28] 0 11] 4 0 13]
  0
  7
]

> &1:add
[ 6
  [5 [1 0] 0 12]
  [0 13]
  9
  2
  [0 2]
  [[8 [9 2.540 0 7] 9 2 [0 4] [0 28] 0 11] 4 0 13]
  0
  7
]
```

This is the uninteresting case of a limb expression resolving to an arm.  Let's look at the more interesting case.

#### Name-based Limb Expressions

A name used as an expression is the other sort of limb expression.  In 1.4 you learned that you could use names to produce a leg of the subject.  Names that resolve to legs of the subject are *faces*.  We evaluated some dojo-defined faces in an earlier lesson:

```
> our
~bitnus-holleb-rocmeg-fotfer--migsum-nidsym-hilput-patmus

> now
~2018.6.6..20.46.28..1e46
```

It's time to cover the other case: when a name resolves to an arm.  This is the special case of arm resolution referred to earlier in the lesson.  When an arm name is used as a limb expression, the arm is evaluated with its parent core as the subject.  Accordingly, the product of this limb expression is whatever is generated by the arm evaluation.

You've already seen arm resolution in action.  Remember that `$` is, by Hoon convention, a special case of a name: it's the name given to the arm in each gate.  Let's look again at the gate for `add`:

```
> add
<1.vng {{a/@ b/@} <31.ohr 1.jmk $143>}>
```

The name of the arm at `+2` is therefore `$`.  In the previous lesson we evaluated `$` using the gate above as the subject:

```
> $:add
0

> +6:add
[a=0 b=0]
```

Remember that the default sample of the gate at `+6` is just `[a=0 b=0]`, and `(0 + 0) = 0`.  Thus, the `$` of `add` evaluates to `0` when it has its parent core, the `add` gate, with the default sample as the subject.

This isn't the only arm resolution you've already done.  One might think that the names `add` and `mul` are faces for gates hidden away somewhere in the dojo subject.  This isn't so!  Each is name of an arm which, when evaluated against its parent core, produces a gate.  What core is this?  For both `add` and `mul` it's the core you see at the context, `+7`, of the gate produced by `add`:

```
> add
<1.vng {{a/@ b/@} <31.ohr 1.jmk $143>}>

> mul
<1.smm {{a/@ b/@} <31.ohr 1.jmk $143>}>
```

The `<31.ohr 1.jmk $143>` at `+7` of each of these gates is how the Hoon pretty-printer represents the parent core.  (It's the same parent core for both gates.)  The battery of this core contains 31 arms, each of which evaluates to a function in the Hoon 'standard library'.  This 'library' is nothing more than a core containing useful basic functions that Hoon often makes available as part of the subject.  You can see the Hoon code defining these arms near the beginning of [hoon.hoon](https://github.com/urbit/arvo/blob/master/sys/hoon.hoon), starting with [`++  add`](https://github.com/urbit/arvo/blob/master/sys/hoon.hoon#L21).

Here are some of the other gates that can be generated from this core in the Hoon standard library:

```
> (dec 18)
17

> (dec 17)
16

> dec
<1.nov {a/@ <31.ohr 1.jmk $143>}>

> (gth 11 7)
%.y

> (gth 7 11)
%.n

> (gth 11 11)
%.n

> gth
<1.axt {{a/@ b/@} <31.ohr 1.jmk $143>}>

> (lth 11 7)
%.n

> (lth 7 11)
%.y

> (lth 11 11)
%.n

> lth
<1.tam {{a/@ b/@} <31.ohr 1.jmk $143>}>

> (max 12 14)
14

> (max 14 14)
14

> (max 14 432)
432

> max
<1.ofs {{a/@ b/@} <31.ohr 1.jmk $143>}>

> (mod 11 7)
4

> (mod 22 7)
1

> (mod 33 7)
5

> mod
<1.aer {{a/@ b/@} <31.ohr 1.jmk $143>}>

> (sub 234 123)
111

> sub
<1.hff {{a/@ b/@} <31.ohr 1.jmk $143>}>
```

### Name Searches and Collisions

It's possible to have 'name collisions' with both ordinary faces and arm names.  That is, nothing prevents one from using the name of some arm as a face too.  For example:

```
> add
<1.vng {{a/@ b/@} <31.ohr 1.jmk $143>}>

> add:add
<1.vng {{a/@ b/@} <31.ohr 1.jmk $143>}>

> add:[add=34 add]
34
```

When you evaluate `[add=34 add]` as the subject, the result is a cell of: (1) `add=34` and (2) the gate evaluated by the `add` arm:

```
> [add=34 add]
[add=34 <1.vng {{a/@ b/@} <31.ohr 1.jmk $143>}>]
```

Hoon doesn't automatically know whether `add` is a face or an arm name until it conducts a search looking for name matches.  If it finds a face first, the value of the face is returned.  If it finds an arm first, the arm will be evaluated and the product returned.  You may use `^` to indicate that you want to skip the first match, and multiple `^`s to indicate multiple skips:

```
> (add 12 14):[add=34 add]
-find.$.+2
[crash message]

> ^add:[add=34 add]
<1.vng {{a/@ b/@} <31.ohr 1.jmk $143>}>

> (^add 12 14):[add=34 add]
26

> add:[add=34 add=~zod add]
34

> ^add:[add=34 add=~zod add]
~zod

> ^^add:[add=34 add=~zod add]
<1.vng {{a/@ b/@} <31.ohr 1.jmk $143>}>
```

But wait---where is the last `add` in the subject?  Again, evaluating `[add=34 add]` gives us:

```
> [add=34 add]
[add=34 <1.vng {{a/@ b/@} <31.ohr 1.jmk $143>}>]
```

The first `add` is easy to spot, but where is the second?  Remember that the parent core of `add` is `<31.ohr 1.jmk $143>`.  The arm name `add` must be somewhere in the battery of that core.  That's where Hoon finds it when it conducts the search for a second `add` in the following:

```
> ^add:[add=34 add]
<1.vng {{a/@ b/@} <31.ohr 1.jmk $143>}>
```

Names themselves are not stored in the noun of the subject.  They're stored as metadata in the type information of the subject.  When Hoon infers that the data type of a certain noun is 'core', it retains the arm names as part of the type information of the core.  This is important; Hoon can't evaluate an arm unless it knows what core to use as the subject.  Hoon is designed so that arm evaluation cannot happen except when a name search is resolved in the core's type information.  That way it always knows which core is used to evaluate each arm.

## Wings and Arms

Remember that a *wing* is a limb search path of the subject, and that a wing expression is just a series of limb expressions connected by the `.` character.  For example, `c.b.a`:

```
> c.b.a:[d=0xdad c=0b11 a=[g='hi' b=[c=99 q=22]]]
99
```

### Wing Resolution to an Arm

When the final limb of a wing path -- that is, the left-most limb expression in the wing -- is a name that resolves to an arm, the arm is evaluated with its parent core as the subject.  In this respect the wing behaves much like a stand-alone name does when it resolves to an arm.  To see this in action, let's produce a subject in which we must use a wing to resolve a search for `add` correctly.

How do we do that?  Remember that there are limitations on name searches.  Let's say Hoon is searching for the name `add` in the subject's type information.  When Hoon comes across a name that doesn't match, that whole subtree of the subject is skipped over for the rest of the search:

```
> add:[a=12 b=[43 add]]
-find.add

> (add 12 14):[a=12 b=[43 add]]
-find.add
```

To evaluate the `add` arm in that expression we need to use a wing:

```
> add.b:[a=12 b=[43 add]]
<1.vng {{a/@ b/@} <31.ohr 1.jmk $143>}>

> (add.b 12 14):[a=12 b=[43 add]]
26
```

### Arms on the Search Path

What if an arm name isn't the final (left-most) limb in the wing?  What if it is elsewhere on the search path?  Normally we might read a wing expression like `a.b.c` as '`a` in `b` in `c`'.  What about `a.b.add`?

Arms are raw Nock formulas, and there isn't much reason to follow a search path into those.  There are no faces or other names in arm Nock formulas!  For this reason, when arm names are included in the search path the search behavior is a little different.  Instead of indicating that the search should continue in the arm itself, an arm name indicates that the search should continue in the parent core of the arm.  So the meaning of `a.b.add` is, roughly, '`a` in `b` in the parent core of `add`'.

It turns out this wing doesn't resolve in `add`'s core.

```
> a.b.add
-find.a.b.add
```

Let's try something else.  Earlier I said that `add` isn't a face for a gate hiding somewhere in the subject -- it's an arm that produces the gate for `add` when evaluated.  Let's prove it.  Gates always have a special name for their lone arm: `$`.  So let's try the wing `$.add` and see if it resolves:

```
> $.add
-find.$.add
```

It doesn't.  Using the arm `add` anywhere other than the (left) end of a wing indicates that the search should continue in `add`'s parent core.  And a search for `$` in that core fails:

```
> add
<1.vng {{a/@ b/@} <31.ohr 1.jmk $143>}>

> +7:add
<31.ohr 1.jmk $143>

> $.+7:add
-find.$.+7
```

If the search for `$` occurs instead in the gate produced by `add` then it will resolve.  Let's set the value of face `add-gate` to the gate for `add` and make that the subject.  Then we can try the wing `$.add-gate` to see if it resolves:

```
> add
<1.vng {{a/@ b/@} <31.ohr 1.jmk $143>}>

> add-gate=add
add-gate=<1.vng {{a/@ b/@} <31.ohr 1.jmk $143>}>

> $.add-gate:add-gate=add
0
```

It does!

There is a more direct way of seeing how arm names work in wing resolution.  We can use address-based limbs in the wing.  For example:

```
> c:[c=[d=15 e=20] f=[g=45 h=50]]
[d=15 e=20]

> -.c:[c=[d=15 e=20] f=[g=45 h=50]]
d=15

> +.c:[c=[d=15 e=20] f=[g=45 h=50]]
e=20

> +1.c:[c=[d=15 e=20] f=[g=45 h=50]]
[d=15 e=20]

> ..c:[c=[d=15 e=20] f=[g=45 h=50]]
[d=15 e=20]
```

Remember that the limb `.` is equivalent to the limb `+1`.  Hence `..c` is the same as `+1.c`.  So let's see what `..add` evaluates to:

```
> ..add
<31.ohr 1.jmk $143>

> add
<1.vng {{a/@ b/@} <31.ohr 1.jmk $143>}>

> .:add
<1.vng {{a/@ b/@} <31.ohr 1.jmk $143>}>
```

As you would expect, `..add` returns the entire parent core of `add`.  `.:add` evaluates to the gate for `add` because the expression to the right of the `:` evaluates `add` and makes it the subject.  The `add` arm is designed to produce the add gate when evaluated.

There are lots of arms in the parent core of `add`.  Let's use some of those arms with wings:

```
> mul.add
<1.smm {{a/@ b/@} <31.ohr 1.jmk $143>}>

> (mul.add 3 10)
30

> (add.mul.add 3 10)
13

> (mul.add.mul.add 3 10)
30
```

These are silly examples, but they illustrate how arm names work in wings.

The `mul` arm is in the battery of the parent core of `add`, so `mul.add` evaluates this `mul` arm to produce the `mul` gate.  `add.mul.add` means '`add` in the parent core of `mul` in the parent core of `add`'.  But the parent core of `mul` is the same as the parent core of `add`, so having both is redundant.

At this point you should have a decent understanding of arms and legs of the subject.  In the next lesson we'll talk a bit more about different kinds of cores.
